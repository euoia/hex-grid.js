require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = (function () {
	/**
	* Exports a constructor taking an options object.
	* @module
	* @example
	* ```js
	* var HexGrid = require('hex-grid.js');
	*
	* var TileFactory = function () {
	*   var _id = 0;
	*   return {
	*     newTile: function () {
	*       var tile = {
	*         id: _id.toString()
	*       };
	*
	*       _id += 1;
	*       return tile;
	*     }
	*   };
	* };
	*
	* var tileFactory = new TileFactory();
	* var hexGrid = new HexGrid({
	*   width: 20,
	*   height: 10,
	*   orientation: 'flat-topped',
	*   layout: 'odd-q',
	*   tileFactory: tileFactory
	* });
	* ```
	* @typicalname HexGrid
	*/

	var _width = null;
	var _height = null;
	var _tiles = null;
	var _tileFactory = null;
	var _orientation = null;
	var _layout = null;

	// Mapping from tile.id to tileIdx.
	var _tileIdMap = null;

	/**
	 * A mapping from the map orientation to an array of valid neighbouring
	 * directions for a tile.
	 */
	var _validDirs = {
		'flat-topped': ['north', 'northeast', 'southeast', 'south', 'southwest',
			'northwest'],
		'pointy-topped': ['northeast', 'east', 'southeast', 'southwest', 'west',
			'northwest']
	};

	/**
	 * Mapping from map orientation to an array of valid layouts.
	 */
	var _validLayouts = {
		'flat-topped': ['odd-q', 'even-q'],
		'pointy-topped': ['odd-r', 'even-r']
	};

	/**
	 * @class
	 * @classdesc A hexagonal grid.
	 * @alias module:hex-grid
	 * @param {array} options HexGrid options.
	 * @param {number} [options.width] The width of the map.
	 * @param {number} [options.height] The height of the map.
	 * @param {tileFactory} [options.tileFactory] A tileFactory object. A
	 * tileFactory is an object that has a `newTile` function property that
	 * when called returns a tile object. The tile objects returned by
	 * `tileFactory.newTile()` must have an `id` property which is unique
	 * across all tiles generated by the tileFactory.
	 * @param {string} [options.orientation] The orientation of the map. Must be
	 * one of: flat-topped, pointy-topped.
	 * @param {string} [options.layout] The layout of the map. Must be one of:
	 * odd-q, even-q, odd-r, even-r.
	 * @see {@link http://redblobgames.com/grids/hexagons} for explanations of
	 * `options.orientation` and `options.layout`.
	 */
	var HexGrid = function(options) {
		if (typeof options === 'undefined') {
			throw new Error('Must provide an options object');
		}

		if (typeof options.width !== 'number') {
			throw new Error('Must provide a number options.width');
		}

		if (typeof options.height !== 'number') {
			throw new Error('Must provide a number options.height');
		}

		if (typeof options.tileFactory !== 'object') {
			throw new Error('Must provide an object options.tileFactory');
		}

		if (typeof(options.tileFactory.newTile) !== 'function') {
			throw new Error('Options.fileFactory must implement a newTile function');
		}

		if (typeof options.orientation !== 'string' ||
			['flat-topped', 'pointy-topped'].indexOf(options.orientation) === -1
		) {
			throw new Error('Must provide a string options.orientation which is' +
				" one of: 'flat-topped', 'pointy-topped'");
		}

		if (typeof options.layout !== 'string' ||
			['odd-q', 'even-q', 'odd-r',
				'even-r'].indexOf(options.layout) === -1
		) {
			throw new Error('Must provide a string options.layout which is' +
				" one of: 'odd-q', 'even-q', 'odd-r', 'even-r'");
		}

		if (_validLayouts[options.orientation].indexOf(options.layout) === -1) {
			throw new Error('Invalid options.layout for the chosen orientation. Must '+
				'be one of: ' + _validLayouts[options.orientation]);
		}

		_width = options.width;
		_height = options.height;
		_tileFactory = options.tileFactory;
		_orientation = options.orientation;
		_layout = options.layout;

		// Initialize each tile on the map.
		_tileIdMap = {};
		_tiles = new Array(_width * _height);
		var numTiles = _tiles.length;
		var tile;
		for (var tileIdx = 0; tileIdx < numTiles; tileIdx += 1) {
			tile = _tileFactory.newTile();
			_tiles[tileIdx] = tile;
			_tileIdMap[tile.id] = tileIdx;
		}
	};

	/**
	 * Gets the width of the grid.
	 * @return {number} The width of the grid.
	 */
	HexGrid.prototype.getWidth = function() {
		return _width;
	};

	/**
	 * Gets the height of the grid.
	 * @return {number} The height of the grid.
	 */
	HexGrid.prototype.getHeight = function() {
		return _height;
	};

	/**
	 * Returns whether a coordinate is within the grid boundaries.
	 * @param {number} x The X coordinate.
	 * @param {number} y The Y coordinate.
	 * @return {bool} Whether the coordinate is within the boundaries of the
	 * grid.
	 */
	HexGrid.prototype.isWithinBoundaries = function(x, y) {
		return x <= _width - 1 &&
			x >= 0 &&
			y <= _height - 1 &&
			y >= 0;
	};

	/**
	 * Gets a specific tile by its x and y coordinates.
	 * @param {number} x The X coordinate.
	 * @param {number} y The Y coordinate.
	 * @return {tile|null} The tile. Null if not a valid coordinate.
	 */
	HexGrid.prototype.getTileByCoords = function(x, y) {
		if (typeof x !== 'number' || typeof y !== 'number') {
			throw new Error('x and y must be integers');
		}

		if (this.isWithinBoundaries(x, y)) {
			return _tiles[(y * _width) + x];
		}

		return null;
	};

	var TileIterator = function() {
		var tileIdx = -0;
		this.next = function() {
			if (tileIdx >= _tiles.length) {
				return null;
			}

			var tile = _tiles[tileIdx];
			tileIdx += 1;
			return tile;
		};
	};

	/**
	 * Returns an iterator with a next() function that iterates through the
	 * tiles in the grid.
	 * @return {object} The iterator object.
	 */
	HexGrid.prototype.getTileIterator = function() {
		return new TileIterator();
	};

	/**
	 * Whether a given direction is valid for this map layout.
	 * @return {bool} Whether the direction is valid.
	 */
	HexGrid.prototype.isValidDirection = function(dir) {
		if (_validDirs[_orientation].indexOf(dir) === -1) {
			return false;
		}

		return true;
	};

	/**
	 * Gets the coordinates of a tile given its ID.
	 * @param {string} tileId The ID of the tile.
	 * @return {object|null} An object with x and y properties.
	 */
	HexGrid.prototype.getCoordsById = function(tileId) {
		var tileIdx = _tileIdMap[tileId];
		if (tileIdx === undefined) {
			return null;
		}

		return {
			x: tileIdx % _width,
			y: Math.floor(tileIdx / _width)
		};
	};

	/**
	 * Gets a tile given its ID.
	 * @param {string} tileId The ID of the tile.
	 * @return {object|null} The tile.
	 */
	HexGrid.prototype.getTileById = function(tileId) {
		var tileIdx = _tileIdMap[tileId];
		if (tileIdx === undefined) {
			throw new Error('Not a valid tileId');
		}

		return _tiles[tileIdx];
	};

	/**
	 * Gets a tile's neighbour given its coordinates and a direction.
	 * @param {number} x The X coordinate of the tile.
	 * @param {number} y The Y coordinate of the tile.
	 * @param {string} dir A direction. One of: north, northeast, east,
	 * southeast, south, southwest, west, northwest.
	 * @return {object|null} The neighbouring tile.
	 */
	HexGrid.prototype.getNeighbourByCoords = function(x, y, dir) {
		if (this.isValidDirection(dir) === false) {
			throw new Error('Not a valid direction: ' + dir);
		}

		// TODO: It might be good to reduce this using maths.
		switch (_layout) {
		case 'odd-q':
			// Flat-top.
			switch (dir) {
			case 'north':
				return this.getTileByCoords(x, y - 1);
			case 'northeast':
				if (x % 2 === 0) {
					return this.getTileByCoords(x + 1, y - 1);
				}
				return this.getTileByCoords(x + 1, y);
			case 'southeast':
				if (x % 2 === 1) {
					return this.getTileByCoords(x + 1, y + 1);
				}
				return this.getTileByCoords(x + 1, y);
			case 'south':
				return this.getTileByCoords(x, y + 1);
			case 'southwest':
				if (x % 2 === 1) {
					return this.getTileByCoords(x - 1, y + 1);
				}
				return this.getTileByCoords(x - 1, y);
			case 'northwest':
				if (x % 2 === 0) {
					return this.getTileByCoords(x - 1, y - 1);
				}
				return this.getTileByCoords(x - 1, y);
			}
			break;
		case 'even-q':
			throw new Error('getNeighbourByCoords not implemented for even-q.');
		case 'odd-r':
			// Pointy-top.
			switch (dir) {
			case 'northeast':
				// On even rows, x doesn't change.
				if (y % 2 === 0) {
					return this.getTileByCoords(x, y - 1);
				}
				return this.getTileByCoords(x + 1, y - 1);
			case 'east':
				return this.getTileByCoords(x + 1, y);
			case 'southeast':
				// On even rows, x doesn't change.
				if (x % 2 === 0) {
					return this.getTileByCoords(x, y + 1);
				}
				return this.getTileByCoords(x, y + 1);
			case 'south':
				return this.getTileByCoords(x, y + 1);
			case 'southwest':
				// On odd rows, x doesn't change.
				if (y % 2 === 1) {
					return this.getTileByCoords(x, y + 1);
				}
				return this.getTileByCoords(x - 1, y + 1);
			case 'west':
				return this.getTileByCoords(x - 1, y);
			case 'northwest':
				// On even rows, x doesn't change.
				if (x % 2 === 0) {
					return this.getTileByCoords(x, y - 1);
				}
				return this.getTileByCoords(x - 1, y - 1);
			}
			break;
		case 'even-r':
			throw new Error('getNeighbourByCoords not implemented for even-r.');
		}

	};

	/**
	 * Gets a tile's neighbour given the tile's ID and a direction.
	 * @param {string} tileId The tile's ID.
	 * @param {string} dir A direction. One of: north, northeast, east,
	 * southeast, south, southwest, west, northwest.
	 * @return {object|null} The neighbouring tile.
	 */
	HexGrid.prototype.getNeighbourById = function(tileId, dir) {
		var coords = this.getCoordsById(tileId);
		return this.getNeighbourByCoords(coords.x, coords.y, dir);
	};

	/**
	 * Gets the position of a tile by its coordinates. Due to the way
	 * hexagonal grids work, the position of half of the tiles are offset by
	 * 0.5.
	 * @param {number} x The X coordinate of the tile.
	 * @param {number} y The Y coordinate of the tile.
	 * @return {object} An object with x and y properties.
	 */
	HexGrid.prototype.getPositionByCoords = function(x, y) {
		var xPos = x,
			yPos = y;

		switch (_layout) {
		// Flat top.
		case 'odd-q':
			if (x % 2 === 1) {
				yPos = y + 0.5;
			}
			break;

		// Pointy top.
		case 'odd-r':
			// Odd rows are offset by half.
			if (y % 2 === 1) {
				xPos = x + 0.5;
			}

			break;
		default:
			throw new Error(
				'getPositionByCoords is not implemented for ' + _layout + '.');
		}

		return {
			x: xPos,
			y: yPos
		};
	};

	/**
	 * Gets the position of a tile by its ID.
	 * @param {string} tileId The tile's ID.
	 * @return {object} An object with x and y properties.
	 */
	HexGrid.prototype.getPositionById = function(tileId) {
		var coords = this.getCoordsById(tileId);
		return this.getPositionByCoords(coords.x, coords.y);
	};

	return HexGrid;
})();

},{}],"/src/App.js":[function(require,module,exports){
var HexGrid = require('../../../src/hex-grid.js');

var TileFactory = function () {
	var _id = 0;
	return {
		newTile: function () {
			var tile = {
				id: _id.toString(),
				type: 'testTile'
			};

			_id += 1;
			return tile;
		},
	};
};

/**
 * Draws tiles by creating DOM elements.
 * @param array options
 * @param object options.parent Parent DOM element.
 */
function DomTileDrawer(options) {
	if (typeof options === 'undefined') {
		throw new Error('must provide an options object');
	}

	if (typeof options.parent !== 'object' ||
		options.parent.hasOwnProperty('childNodes' === false)
	) {
		throw new Error('options.container must be an HTML element');
	}

	if (typeof options.tileSize !== 'number') {
		throw new Error('options.tileSize must be a number');
	}


	this.tileSize = options.tileSize;
	this.parent = options.parent;
}

DomTileDrawer.prototype.createDomTile = function(xPos, yPos) {
	var hexWidth = this.tileSize * 2;
	// 0.866 = (Math.sqrt(3) / 2);
	// 0.7510 = 362 / 482
	var tileHeight = hexWidth * 0.7510;

	var tileDiv = document.createElement('div');
	tileDiv.style.position = 'absolute';
	tileDiv.style.width = hexWidth + 'px';
	tileDiv.style.height = tileHeight + 'px';

	tileDiv.style.left = (xPos * hexWidth * 0.75) + 'px';
	tileDiv.style.top = (yPos * tileHeight) + 'px';

	tileDiv.style.backgroundSize = hexWidth + 'px ' + tileHeight  + 'px';

	this.parent.appendChild(tileDiv);

	return tileDiv;
};

DomTileDrawer.prototype.setTileImage = function(element, imgFilename) {
	if (typeof element !== 'object') {
		throw new Error('element is not an object');
	}

	element.style.backgroundImage = 'url(' + imgFilename + ')';
};

var tileFactory = new TileFactory();

/**
 * @param array options
 * @param object options.container DOM element for the grid.
 * @param object options.tileSize Tile height/width in pixels.
 * @param object options.width Grid width in tiles.
 * @param object options.height Grid height in tiles.
 * @param object options.onAnimationComplete Callback for when animation
 *        completes.
 */
function App(options) {
	if (typeof options === 'undefined') {
		throw new Error('must provide an options object');
	}

	if (typeof options.container !== 'object') {
		throw new Error('options.container must be an HTML element');
	}

	this.container = options.container;

	if (typeof options.tileSize !== 'number') {
		throw new Error('options.tileSize must be a number');
	}

	if (typeof options.width !== 'number') {
		throw new Error('options.width must be a number');
	}

	if (typeof options.height !== 'number') {
		throw new Error('options.height must be a number');
	}

	this.width = options.width;
	this.height = options.height;
	this.tileSize = options.tileSize;
	this.onAnimationComplete = options.onAnimationComplete;

	this.hexGrid = new HexGrid({
		width: options.width,
		height: options.height,
		orientation: 'flat-topped',
		layout: 'odd-q',
		tileFactory: tileFactory
	});

	this.dtd = new DomTileDrawer({
		parent: options.container,
		tileSize: this.tileSize
	});

	var iter = this.hexGrid.getTileIterator();
	var tile = iter.next();
	var tilePos;
	while (tile !== null) {
		tilePos = this.hexGrid.getPositionById(tile.id);
		tile.element = this.dtd.createDomTile(tilePos.x, tilePos.y);
		this.dtd.setTileImage(
			tile.element,
			this.getTileImageByPos(tilePos.x, tilePos.y)
		);
		tile = iter.next();
	}

	this.attachMouseEvents();
	this.animateLeftToRight();
}

App.prototype.getTileImageByPos = function(x, y) {
	// Results in a dark border.
	if (x === 0 || x === this.width - 1 ||
		y === 0 ||
		(y === this.height - 1 && x % 2 === 0) ||
		(y === this.height - 0.5 && x % 2 === 1)
	) {
		return './img/dark-circle.png';
	}

	return './img/light-circle.png';
};

App.prototype.attachMouseEvents = function() {
	var iter = this.hexGrid.getTileIterator();
	var tile = iter.next();
	while (tile !== null) {
		tile.element.onmouseover = function(tile) {
			return function () {
				if (tile.selected !== true) {
					this.dtd.setTileImage(tile.element, './img/dark-circle.png');
				}
			}.bind(this);
		}.bind(this)(tile);

		tile.element.onmouseout = function(tile) {
			return function () {
				if (tile.selected !== true) {
					this.dtd.setTileImage(tile.element, './img/light-circle.png');
				}
			}.bind(this);
		}.bind(this)(tile);

		tile.element.onmousedown = function(tile) {
			return function () {
				tile.selected = true;
				this.dtd.setTileImage(tile.element, './img/red-circle.png');
			}.bind(this);
		}.bind(this)(tile);

		tile = iter.next();
	}
};

App.prototype.animateLeftToRight = function() {
	var iter = this.hexGrid.getTileIterator();
	var tile = iter.next();
	var animationInterval;

	var animate = function() {
		if (tile === null) {
			window.clearInterval(animationInterval);
			this.animationComplete();
			return;
		}

		this.dtd.setTileImage(tile.element, './img/dark-circle.png');
		tile = iter.next();
	}.bind(this);

	animationInterval = window.setInterval(animate, 50);
};

App.prototype.animationComplete = function() {
	if (typeof this.onAnimationComplete === 'function') {
		this.onAnimationComplete.call(null, this);
	}
};

module.exports = App;

},{"../../../src/hex-grid.js":1}]},{},[])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy5udm0vdmVyc2lvbnMvaW8uanMvdjEuMy4wL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiLi4vLi4vc3JjL2hleC1ncmlkLmpzIiwic3JjL0FwcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwibW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuXHQvKipcblx0KiBFeHBvcnRzIGEgY29uc3RydWN0b3IgdGFraW5nIGFuIG9wdGlvbnMgb2JqZWN0LlxuXHQqIEBtb2R1bGVcblx0KiBAZXhhbXBsZVxuXHQqIGBgYGpzXG5cdCogdmFyIEhleEdyaWQgPSByZXF1aXJlKCdoZXgtZ3JpZC5qcycpO1xuXHQqXG5cdCogdmFyIFRpbGVGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuXHQqICAgdmFyIF9pZCA9IDA7XG5cdCogICByZXR1cm4ge1xuXHQqICAgICBuZXdUaWxlOiBmdW5jdGlvbiAoKSB7XG5cdCogICAgICAgdmFyIHRpbGUgPSB7XG5cdCogICAgICAgICBpZDogX2lkLnRvU3RyaW5nKClcblx0KiAgICAgICB9O1xuXHQqXG5cdCogICAgICAgX2lkICs9IDE7XG5cdCogICAgICAgcmV0dXJuIHRpbGU7XG5cdCogICAgIH1cblx0KiAgIH07XG5cdCogfTtcblx0KlxuXHQqIHZhciB0aWxlRmFjdG9yeSA9IG5ldyBUaWxlRmFjdG9yeSgpO1xuXHQqIHZhciBoZXhHcmlkID0gbmV3IEhleEdyaWQoe1xuXHQqICAgd2lkdGg6IDIwLFxuXHQqICAgaGVpZ2h0OiAxMCxcblx0KiAgIG9yaWVudGF0aW9uOiAnZmxhdC10b3BwZWQnLFxuXHQqICAgbGF5b3V0OiAnb2RkLXEnLFxuXHQqICAgdGlsZUZhY3Rvcnk6IHRpbGVGYWN0b3J5XG5cdCogfSk7XG5cdCogYGBgXG5cdCogQHR5cGljYWxuYW1lIEhleEdyaWRcblx0Ki9cblxuXHR2YXIgX3dpZHRoID0gbnVsbDtcblx0dmFyIF9oZWlnaHQgPSBudWxsO1xuXHR2YXIgX3RpbGVzID0gbnVsbDtcblx0dmFyIF90aWxlRmFjdG9yeSA9IG51bGw7XG5cdHZhciBfb3JpZW50YXRpb24gPSBudWxsO1xuXHR2YXIgX2xheW91dCA9IG51bGw7XG5cblx0Ly8gTWFwcGluZyBmcm9tIHRpbGUuaWQgdG8gdGlsZUlkeC5cblx0dmFyIF90aWxlSWRNYXAgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBBIG1hcHBpbmcgZnJvbSB0aGUgbWFwIG9yaWVudGF0aW9uIHRvIGFuIGFycmF5IG9mIHZhbGlkIG5laWdoYm91cmluZ1xuXHQgKiBkaXJlY3Rpb25zIGZvciBhIHRpbGUuXG5cdCAqL1xuXHR2YXIgX3ZhbGlkRGlycyA9IHtcblx0XHQnZmxhdC10b3BwZWQnOiBbJ25vcnRoJywgJ25vcnRoZWFzdCcsICdzb3V0aGVhc3QnLCAnc291dGgnLCAnc291dGh3ZXN0Jyxcblx0XHRcdCdub3J0aHdlc3QnXSxcblx0XHQncG9pbnR5LXRvcHBlZCc6IFsnbm9ydGhlYXN0JywgJ2Vhc3QnLCAnc291dGhlYXN0JywgJ3NvdXRod2VzdCcsICd3ZXN0Jyxcblx0XHRcdCdub3J0aHdlc3QnXVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBNYXBwaW5nIGZyb20gbWFwIG9yaWVudGF0aW9uIHRvIGFuIGFycmF5IG9mIHZhbGlkIGxheW91dHMuXG5cdCAqL1xuXHR2YXIgX3ZhbGlkTGF5b3V0cyA9IHtcblx0XHQnZmxhdC10b3BwZWQnOiBbJ29kZC1xJywgJ2V2ZW4tcSddLFxuXHRcdCdwb2ludHktdG9wcGVkJzogWydvZGQtcicsICdldmVuLXInXVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBAY2xhc3Ncblx0ICogQGNsYXNzZGVzYyBBIGhleGFnb25hbCBncmlkLlxuXHQgKiBAYWxpYXMgbW9kdWxlOmhleC1ncmlkXG5cdCAqIEBwYXJhbSB7YXJyYXl9IG9wdGlvbnMgSGV4R3JpZCBvcHRpb25zLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMud2lkdGhdIFRoZSB3aWR0aCBvZiB0aGUgbWFwLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaGVpZ2h0XSBUaGUgaGVpZ2h0IG9mIHRoZSBtYXAuXG5cdCAqIEBwYXJhbSB7dGlsZUZhY3Rvcnl9IFtvcHRpb25zLnRpbGVGYWN0b3J5XSBBIHRpbGVGYWN0b3J5IG9iamVjdC4gQVxuXHQgKiB0aWxlRmFjdG9yeSBpcyBhbiBvYmplY3QgdGhhdCBoYXMgYSBgbmV3VGlsZWAgZnVuY3Rpb24gcHJvcGVydHkgdGhhdFxuXHQgKiB3aGVuIGNhbGxlZCByZXR1cm5zIGEgdGlsZSBvYmplY3QuIFRoZSB0aWxlIG9iamVjdHMgcmV0dXJuZWQgYnlcblx0ICogYHRpbGVGYWN0b3J5Lm5ld1RpbGUoKWAgbXVzdCBoYXZlIGFuIGBpZGAgcHJvcGVydHkgd2hpY2ggaXMgdW5pcXVlXG5cdCAqIGFjcm9zcyBhbGwgdGlsZXMgZ2VuZXJhdGVkIGJ5IHRoZSB0aWxlRmFjdG9yeS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9yaWVudGF0aW9uXSBUaGUgb3JpZW50YXRpb24gb2YgdGhlIG1hcC4gTXVzdCBiZVxuXHQgKiBvbmUgb2Y6IGZsYXQtdG9wcGVkLCBwb2ludHktdG9wcGVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGF5b3V0XSBUaGUgbGF5b3V0IG9mIHRoZSBtYXAuIE11c3QgYmUgb25lIG9mOlxuXHQgKiBvZGQtcSwgZXZlbi1xLCBvZGQtciwgZXZlbi1yLlxuXHQgKiBAc2VlIHtAbGluayBodHRwOi8vcmVkYmxvYmdhbWVzLmNvbS9ncmlkcy9oZXhhZ29uc30gZm9yIGV4cGxhbmF0aW9ucyBvZlxuXHQgKiBgb3B0aW9ucy5vcmllbnRhdGlvbmAgYW5kIGBvcHRpb25zLmxheW91dGAuXG5cdCAqL1xuXHR2YXIgSGV4R3JpZCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhbiBvcHRpb25zIG9iamVjdCcpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucy53aWR0aCAhPT0gJ251bWJlcicpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGEgbnVtYmVyIG9wdGlvbnMud2lkdGgnKTtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIG9wdGlvbnMuaGVpZ2h0ICE9PSAnbnVtYmVyJykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgYSBudW1iZXIgb3B0aW9ucy5oZWlnaHQnKTtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIG9wdGlvbnMudGlsZUZhY3RvcnkgIT09ICdvYmplY3QnKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhbiBvYmplY3Qgb3B0aW9ucy50aWxlRmFjdG9yeScpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2Yob3B0aW9ucy50aWxlRmFjdG9yeS5uZXdUaWxlKSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdPcHRpb25zLmZpbGVGYWN0b3J5IG11c3QgaW1wbGVtZW50IGEgbmV3VGlsZSBmdW5jdGlvbicpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucy5vcmllbnRhdGlvbiAhPT0gJ3N0cmluZycgfHxcblx0XHRcdFsnZmxhdC10b3BwZWQnLCAncG9pbnR5LXRvcHBlZCddLmluZGV4T2Yob3B0aW9ucy5vcmllbnRhdGlvbikgPT09IC0xXG5cdFx0KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBhIHN0cmluZyBvcHRpb25zLm9yaWVudGF0aW9uIHdoaWNoIGlzJyArXG5cdFx0XHRcdFwiIG9uZSBvZjogJ2ZsYXQtdG9wcGVkJywgJ3BvaW50eS10b3BwZWQnXCIpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucy5sYXlvdXQgIT09ICdzdHJpbmcnIHx8XG5cdFx0XHRbJ29kZC1xJywgJ2V2ZW4tcScsICdvZGQtcicsXG5cdFx0XHRcdCdldmVuLXInXS5pbmRleE9mKG9wdGlvbnMubGF5b3V0KSA9PT0gLTFcblx0XHQpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGEgc3RyaW5nIG9wdGlvbnMubGF5b3V0IHdoaWNoIGlzJyArXG5cdFx0XHRcdFwiIG9uZSBvZjogJ29kZC1xJywgJ2V2ZW4tcScsICdvZGQtcicsICdldmVuLXInXCIpO1xuXHRcdH1cblxuXHRcdGlmIChfdmFsaWRMYXlvdXRzW29wdGlvbnMub3JpZW50YXRpb25dLmluZGV4T2Yob3B0aW9ucy5sYXlvdXQpID09PSAtMSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9wdGlvbnMubGF5b3V0IGZvciB0aGUgY2hvc2VuIG9yaWVudGF0aW9uLiBNdXN0ICcrXG5cdFx0XHRcdCdiZSBvbmUgb2Y6ICcgKyBfdmFsaWRMYXlvdXRzW29wdGlvbnMub3JpZW50YXRpb25dKTtcblx0XHR9XG5cblx0XHRfd2lkdGggPSBvcHRpb25zLndpZHRoO1xuXHRcdF9oZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcblx0XHRfdGlsZUZhY3RvcnkgPSBvcHRpb25zLnRpbGVGYWN0b3J5O1xuXHRcdF9vcmllbnRhdGlvbiA9IG9wdGlvbnMub3JpZW50YXRpb247XG5cdFx0X2xheW91dCA9IG9wdGlvbnMubGF5b3V0O1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSBlYWNoIHRpbGUgb24gdGhlIG1hcC5cblx0XHRfdGlsZUlkTWFwID0ge307XG5cdFx0X3RpbGVzID0gbmV3IEFycmF5KF93aWR0aCAqIF9oZWlnaHQpO1xuXHRcdHZhciBudW1UaWxlcyA9IF90aWxlcy5sZW5ndGg7XG5cdFx0dmFyIHRpbGU7XG5cdFx0Zm9yICh2YXIgdGlsZUlkeCA9IDA7IHRpbGVJZHggPCBudW1UaWxlczsgdGlsZUlkeCArPSAxKSB7XG5cdFx0XHR0aWxlID0gX3RpbGVGYWN0b3J5Lm5ld1RpbGUoKTtcblx0XHRcdF90aWxlc1t0aWxlSWR4XSA9IHRpbGU7XG5cdFx0XHRfdGlsZUlkTWFwW3RpbGUuaWRdID0gdGlsZUlkeDtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIHdpZHRoIG9mIHRoZSBncmlkLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgZ3JpZC5cblx0ICovXG5cdEhleEdyaWQucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIF93aWR0aDtcblx0fTtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBncmlkLlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBoZWlnaHQgb2YgdGhlIGdyaWQuXG5cdCAqL1xuXHRIZXhHcmlkLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gX2hlaWdodDtcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIGEgY29vcmRpbmF0ZSBpcyB3aXRoaW4gdGhlIGdyaWQgYm91bmRhcmllcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZS5cblx0ICogQHJldHVybiB7Ym9vbH0gV2hldGhlciB0aGUgY29vcmRpbmF0ZSBpcyB3aXRoaW4gdGhlIGJvdW5kYXJpZXMgb2YgdGhlXG5cdCAqIGdyaWQuXG5cdCAqL1xuXHRIZXhHcmlkLnByb3RvdHlwZS5pc1dpdGhpbkJvdW5kYXJpZXMgPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0cmV0dXJuIHggPD0gX3dpZHRoIC0gMSAmJlxuXHRcdFx0eCA+PSAwICYmXG5cdFx0XHR5IDw9IF9oZWlnaHQgLSAxICYmXG5cdFx0XHR5ID49IDA7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldHMgYSBzcGVjaWZpYyB0aWxlIGJ5IGl0cyB4IGFuZCB5IGNvb3JkaW5hdGVzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCBUaGUgWCBjb29yZGluYXRlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geSBUaGUgWSBjb29yZGluYXRlLlxuXHQgKiBAcmV0dXJuIHt0aWxlfG51bGx9IFRoZSB0aWxlLiBOdWxsIGlmIG5vdCBhIHZhbGlkIGNvb3JkaW5hdGUuXG5cdCAqL1xuXHRIZXhHcmlkLnByb3RvdHlwZS5nZXRUaWxlQnlDb29yZHMgPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0aWYgKHR5cGVvZiB4ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgeSAhPT0gJ251bWJlcicpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcigneCBhbmQgeSBtdXN0IGJlIGludGVnZXJzJyk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuaXNXaXRoaW5Cb3VuZGFyaWVzKHgsIHkpKSB7XG5cdFx0XHRyZXR1cm4gX3RpbGVzWyh5ICogX3dpZHRoKSArIHhdO1xuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdHZhciBUaWxlSXRlcmF0b3IgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGlsZUlkeCA9IC0wO1xuXHRcdHRoaXMubmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHRpbGVJZHggPj0gX3RpbGVzLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHRpbGUgPSBfdGlsZXNbdGlsZUlkeF07XG5cdFx0XHR0aWxlSWR4ICs9IDE7XG5cdFx0XHRyZXR1cm4gdGlsZTtcblx0XHR9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIHdpdGggYSBuZXh0KCkgZnVuY3Rpb24gdGhhdCBpdGVyYXRlcyB0aHJvdWdoIHRoZVxuXHQgKiB0aWxlcyBpbiB0aGUgZ3JpZC5cblx0ICogQHJldHVybiB7b2JqZWN0fSBUaGUgaXRlcmF0b3Igb2JqZWN0LlxuXHQgKi9cblx0SGV4R3JpZC5wcm90b3R5cGUuZ2V0VGlsZUl0ZXJhdG9yID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBUaWxlSXRlcmF0b3IoKTtcblx0fTtcblxuXHQvKipcblx0ICogV2hldGhlciBhIGdpdmVuIGRpcmVjdGlvbiBpcyB2YWxpZCBmb3IgdGhpcyBtYXAgbGF5b3V0LlxuXHQgKiBAcmV0dXJuIHtib29sfSBXaGV0aGVyIHRoZSBkaXJlY3Rpb24gaXMgdmFsaWQuXG5cdCAqL1xuXHRIZXhHcmlkLnByb3RvdHlwZS5pc1ZhbGlkRGlyZWN0aW9uID0gZnVuY3Rpb24oZGlyKSB7XG5cdFx0aWYgKF92YWxpZERpcnNbX29yaWVudGF0aW9uXS5pbmRleE9mKGRpcikgPT09IC0xKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGNvb3JkaW5hdGVzIG9mIGEgdGlsZSBnaXZlbiBpdHMgSUQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0aWxlSWQgVGhlIElEIG9mIHRoZSB0aWxlLlxuXHQgKiBAcmV0dXJuIHtvYmplY3R8bnVsbH0gQW4gb2JqZWN0IHdpdGggeCBhbmQgeSBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0SGV4R3JpZC5wcm90b3R5cGUuZ2V0Q29vcmRzQnlJZCA9IGZ1bmN0aW9uKHRpbGVJZCkge1xuXHRcdHZhciB0aWxlSWR4ID0gX3RpbGVJZE1hcFt0aWxlSWRdO1xuXHRcdGlmICh0aWxlSWR4ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR4OiB0aWxlSWR4ICUgX3dpZHRoLFxuXHRcdFx0eTogTWF0aC5mbG9vcih0aWxlSWR4IC8gX3dpZHRoKVxuXHRcdH07XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldHMgYSB0aWxlIGdpdmVuIGl0cyBJRC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRpbGVJZCBUaGUgSUQgb2YgdGhlIHRpbGUuXG5cdCAqIEByZXR1cm4ge29iamVjdHxudWxsfSBUaGUgdGlsZS5cblx0ICovXG5cdEhleEdyaWQucHJvdG90eXBlLmdldFRpbGVCeUlkID0gZnVuY3Rpb24odGlsZUlkKSB7XG5cdFx0dmFyIHRpbGVJZHggPSBfdGlsZUlkTWFwW3RpbGVJZF07XG5cdFx0aWYgKHRpbGVJZHggPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdOb3QgYSB2YWxpZCB0aWxlSWQnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gX3RpbGVzW3RpbGVJZHhdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXRzIGEgdGlsZSdzIG5laWdoYm91ciBnaXZlbiBpdHMgY29vcmRpbmF0ZXMgYW5kIGEgZGlyZWN0aW9uLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB0aWxlLlxuXHQgKiBAcGFyYW0ge251bWJlcn0geSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSB0aWxlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZGlyIEEgZGlyZWN0aW9uLiBPbmUgb2Y6IG5vcnRoLCBub3J0aGVhc3QsIGVhc3QsXG5cdCAqIHNvdXRoZWFzdCwgc291dGgsIHNvdXRod2VzdCwgd2VzdCwgbm9ydGh3ZXN0LlxuXHQgKiBAcmV0dXJuIHtvYmplY3R8bnVsbH0gVGhlIG5laWdoYm91cmluZyB0aWxlLlxuXHQgKi9cblx0SGV4R3JpZC5wcm90b3R5cGUuZ2V0TmVpZ2hib3VyQnlDb29yZHMgPSBmdW5jdGlvbih4LCB5LCBkaXIpIHtcblx0XHRpZiAodGhpcy5pc1ZhbGlkRGlyZWN0aW9uKGRpcikgPT09IGZhbHNlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIHZhbGlkIGRpcmVjdGlvbjogJyArIGRpcik7XG5cdFx0fVxuXG5cdFx0Ly8gVE9ETzogSXQgbWlnaHQgYmUgZ29vZCB0byByZWR1Y2UgdGhpcyB1c2luZyBtYXRocy5cblx0XHRzd2l0Y2ggKF9sYXlvdXQpIHtcblx0XHRjYXNlICdvZGQtcSc6XG5cdFx0XHQvLyBGbGF0LXRvcC5cblx0XHRcdHN3aXRjaCAoZGlyKSB7XG5cdFx0XHRjYXNlICdub3J0aCc6XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldFRpbGVCeUNvb3Jkcyh4LCB5IC0gMSk7XG5cdFx0XHRjYXNlICdub3J0aGVhc3QnOlxuXHRcdFx0XHRpZiAoeCAlIDIgPT09IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRUaWxlQnlDb29yZHMoeCArIDEsIHkgLSAxKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRUaWxlQnlDb29yZHMoeCArIDEsIHkpO1xuXHRcdFx0Y2FzZSAnc291dGhlYXN0Jzpcblx0XHRcdFx0aWYgKHggJSAyID09PSAxKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0VGlsZUJ5Q29vcmRzKHggKyAxLCB5ICsgMSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0VGlsZUJ5Q29vcmRzKHggKyAxLCB5KTtcblx0XHRcdGNhc2UgJ3NvdXRoJzpcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0VGlsZUJ5Q29vcmRzKHgsIHkgKyAxKTtcblx0XHRcdGNhc2UgJ3NvdXRod2VzdCc6XG5cdFx0XHRcdGlmICh4ICUgMiA9PT0gMSkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmdldFRpbGVCeUNvb3Jkcyh4IC0gMSwgeSArIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldFRpbGVCeUNvb3Jkcyh4IC0gMSwgeSk7XG5cdFx0XHRjYXNlICdub3J0aHdlc3QnOlxuXHRcdFx0XHRpZiAoeCAlIDIgPT09IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRUaWxlQnlDb29yZHMoeCAtIDEsIHkgLSAxKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRUaWxlQnlDb29yZHMoeCAtIDEsIHkpO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnZXZlbi1xJzpcblx0XHRcdHRocm93IG5ldyBFcnJvcignZ2V0TmVpZ2hib3VyQnlDb29yZHMgbm90IGltcGxlbWVudGVkIGZvciBldmVuLXEuJyk7XG5cdFx0Y2FzZSAnb2RkLXInOlxuXHRcdFx0Ly8gUG9pbnR5LXRvcC5cblx0XHRcdHN3aXRjaCAoZGlyKSB7XG5cdFx0XHRjYXNlICdub3J0aGVhc3QnOlxuXHRcdFx0XHQvLyBPbiBldmVuIHJvd3MsIHggZG9lc24ndCBjaGFuZ2UuXG5cdFx0XHRcdGlmICh5ICUgMiA9PT0gMCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmdldFRpbGVCeUNvb3Jkcyh4LCB5IC0gMSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0VGlsZUJ5Q29vcmRzKHggKyAxLCB5IC0gMSk7XG5cdFx0XHRjYXNlICdlYXN0Jzpcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0VGlsZUJ5Q29vcmRzKHggKyAxLCB5KTtcblx0XHRcdGNhc2UgJ3NvdXRoZWFzdCc6XG5cdFx0XHRcdC8vIE9uIGV2ZW4gcm93cywgeCBkb2Vzbid0IGNoYW5nZS5cblx0XHRcdFx0aWYgKHggJSAyID09PSAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0VGlsZUJ5Q29vcmRzKHgsIHkgKyAxKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRUaWxlQnlDb29yZHMoeCwgeSArIDEpO1xuXHRcdFx0Y2FzZSAnc291dGgnOlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRUaWxlQnlDb29yZHMoeCwgeSArIDEpO1xuXHRcdFx0Y2FzZSAnc291dGh3ZXN0Jzpcblx0XHRcdFx0Ly8gT24gb2RkIHJvd3MsIHggZG9lc24ndCBjaGFuZ2UuXG5cdFx0XHRcdGlmICh5ICUgMiA9PT0gMSkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmdldFRpbGVCeUNvb3Jkcyh4LCB5ICsgMSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0VGlsZUJ5Q29vcmRzKHggLSAxLCB5ICsgMSk7XG5cdFx0XHRjYXNlICd3ZXN0Jzpcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0VGlsZUJ5Q29vcmRzKHggLSAxLCB5KTtcblx0XHRcdGNhc2UgJ25vcnRod2VzdCc6XG5cdFx0XHRcdC8vIE9uIGV2ZW4gcm93cywgeCBkb2Vzbid0IGNoYW5nZS5cblx0XHRcdFx0aWYgKHggJSAyID09PSAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0VGlsZUJ5Q29vcmRzKHgsIHkgLSAxKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRUaWxlQnlDb29yZHMoeCAtIDEsIHkgLSAxKTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ2V2ZW4tcic6XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2dldE5laWdoYm91ckJ5Q29vcmRzIG5vdCBpbXBsZW1lbnRlZCBmb3IgZXZlbi1yLicpO1xuXHRcdH1cblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXRzIGEgdGlsZSdzIG5laWdoYm91ciBnaXZlbiB0aGUgdGlsZSdzIElEIGFuZCBhIGRpcmVjdGlvbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRpbGVJZCBUaGUgdGlsZSdzIElELlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZGlyIEEgZGlyZWN0aW9uLiBPbmUgb2Y6IG5vcnRoLCBub3J0aGVhc3QsIGVhc3QsXG5cdCAqIHNvdXRoZWFzdCwgc291dGgsIHNvdXRod2VzdCwgd2VzdCwgbm9ydGh3ZXN0LlxuXHQgKiBAcmV0dXJuIHtvYmplY3R8bnVsbH0gVGhlIG5laWdoYm91cmluZyB0aWxlLlxuXHQgKi9cblx0SGV4R3JpZC5wcm90b3R5cGUuZ2V0TmVpZ2hib3VyQnlJZCA9IGZ1bmN0aW9uKHRpbGVJZCwgZGlyKSB7XG5cdFx0dmFyIGNvb3JkcyA9IHRoaXMuZ2V0Q29vcmRzQnlJZCh0aWxlSWQpO1xuXHRcdHJldHVybiB0aGlzLmdldE5laWdoYm91ckJ5Q29vcmRzKGNvb3Jkcy54LCBjb29yZHMueSwgZGlyKTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgcG9zaXRpb24gb2YgYSB0aWxlIGJ5IGl0cyBjb29yZGluYXRlcy4gRHVlIHRvIHRoZSB3YXlcblx0ICogaGV4YWdvbmFsIGdyaWRzIHdvcmssIHRoZSBwb3NpdGlvbiBvZiBoYWxmIG9mIHRoZSB0aWxlcyBhcmUgb2Zmc2V0IGJ5XG5cdCAqIDAuNS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgdGlsZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgdGlsZS5cblx0ICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB4IGFuZCB5IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRIZXhHcmlkLnByb3RvdHlwZS5nZXRQb3NpdGlvbkJ5Q29vcmRzID0gZnVuY3Rpb24oeCwgeSkge1xuXHRcdHZhciB4UG9zID0geCxcblx0XHRcdHlQb3MgPSB5O1xuXG5cdFx0c3dpdGNoIChfbGF5b3V0KSB7XG5cdFx0Ly8gRmxhdCB0b3AuXG5cdFx0Y2FzZSAnb2RkLXEnOlxuXHRcdFx0aWYgKHggJSAyID09PSAxKSB7XG5cdFx0XHRcdHlQb3MgPSB5ICsgMC41O1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cblx0XHQvLyBQb2ludHkgdG9wLlxuXHRcdGNhc2UgJ29kZC1yJzpcblx0XHRcdC8vIE9kZCByb3dzIGFyZSBvZmZzZXQgYnkgaGFsZi5cblx0XHRcdGlmICh5ICUgMiA9PT0gMSkge1xuXHRcdFx0XHR4UG9zID0geCArIDAuNTtcblx0XHRcdH1cblxuXHRcdFx0YnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0J2dldFBvc2l0aW9uQnlDb29yZHMgaXMgbm90IGltcGxlbWVudGVkIGZvciAnICsgX2xheW91dCArICcuJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHg6IHhQb3MsXG5cdFx0XHR5OiB5UG9zXG5cdFx0fTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgcG9zaXRpb24gb2YgYSB0aWxlIGJ5IGl0cyBJRC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRpbGVJZCBUaGUgdGlsZSdzIElELlxuXHQgKiBAcmV0dXJuIHtvYmplY3R9IEFuIG9iamVjdCB3aXRoIHggYW5kIHkgcHJvcGVydGllcy5cblx0ICovXG5cdEhleEdyaWQucHJvdG90eXBlLmdldFBvc2l0aW9uQnlJZCA9IGZ1bmN0aW9uKHRpbGVJZCkge1xuXHRcdHZhciBjb29yZHMgPSB0aGlzLmdldENvb3Jkc0J5SWQodGlsZUlkKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRQb3NpdGlvbkJ5Q29vcmRzKGNvb3Jkcy54LCBjb29yZHMueSk7XG5cdH07XG5cblx0cmV0dXJuIEhleEdyaWQ7XG59KSgpO1xuIiwidmFyIEhleEdyaWQgPSByZXF1aXJlKCcuLi8uLi8uLi9zcmMvaGV4LWdyaWQuanMnKTtcblxudmFyIFRpbGVGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgX2lkID0gMDtcblx0cmV0dXJuIHtcblx0XHRuZXdUaWxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgdGlsZSA9IHtcblx0XHRcdFx0aWQ6IF9pZC50b1N0cmluZygpLFxuXHRcdFx0XHR0eXBlOiAndGVzdFRpbGUnXG5cdFx0XHR9O1xuXG5cdFx0XHRfaWQgKz0gMTtcblx0XHRcdHJldHVybiB0aWxlO1xuXHRcdH0sXG5cdH07XG59O1xuXG4vKipcbiAqIERyYXdzIHRpbGVzIGJ5IGNyZWF0aW5nIERPTSBlbGVtZW50cy5cbiAqIEBwYXJhbSBhcnJheSBvcHRpb25zXG4gKiBAcGFyYW0gb2JqZWN0IG9wdGlvbnMucGFyZW50IFBhcmVudCBET00gZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gRG9tVGlsZURyYXdlcihvcHRpb25zKSB7XG5cdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ211c3QgcHJvdmlkZSBhbiBvcHRpb25zIG9iamVjdCcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBvcHRpb25zLnBhcmVudCAhPT0gJ29iamVjdCcgfHxcblx0XHRvcHRpb25zLnBhcmVudC5oYXNPd25Qcm9wZXJ0eSgnY2hpbGROb2RlcycgPT09IGZhbHNlKVxuXHQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuY29udGFpbmVyIG11c3QgYmUgYW4gSFRNTCBlbGVtZW50Jyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG9wdGlvbnMudGlsZVNpemUgIT09ICdudW1iZXInKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLnRpbGVTaXplIG11c3QgYmUgYSBudW1iZXInKTtcblx0fVxuXG5cblx0dGhpcy50aWxlU2l6ZSA9IG9wdGlvbnMudGlsZVNpemU7XG5cdHRoaXMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG59XG5cbkRvbVRpbGVEcmF3ZXIucHJvdG90eXBlLmNyZWF0ZURvbVRpbGUgPSBmdW5jdGlvbih4UG9zLCB5UG9zKSB7XG5cdHZhciBoZXhXaWR0aCA9IHRoaXMudGlsZVNpemUgKiAyO1xuXHQvLyAwLjg2NiA9IChNYXRoLnNxcnQoMykgLyAyKTtcblx0Ly8gMC43NTEwID0gMzYyIC8gNDgyXG5cdHZhciB0aWxlSGVpZ2h0ID0gaGV4V2lkdGggKiAwLjc1MTA7XG5cblx0dmFyIHRpbGVEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0dGlsZURpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cdHRpbGVEaXYuc3R5bGUud2lkdGggPSBoZXhXaWR0aCArICdweCc7XG5cdHRpbGVEaXYuc3R5bGUuaGVpZ2h0ID0gdGlsZUhlaWdodCArICdweCc7XG5cblx0dGlsZURpdi5zdHlsZS5sZWZ0ID0gKHhQb3MgKiBoZXhXaWR0aCAqIDAuNzUpICsgJ3B4Jztcblx0dGlsZURpdi5zdHlsZS50b3AgPSAoeVBvcyAqIHRpbGVIZWlnaHQpICsgJ3B4JztcblxuXHR0aWxlRGl2LnN0eWxlLmJhY2tncm91bmRTaXplID0gaGV4V2lkdGggKyAncHggJyArIHRpbGVIZWlnaHQgICsgJ3B4JztcblxuXHR0aGlzLnBhcmVudC5hcHBlbmRDaGlsZCh0aWxlRGl2KTtcblxuXHRyZXR1cm4gdGlsZURpdjtcbn07XG5cbkRvbVRpbGVEcmF3ZXIucHJvdG90eXBlLnNldFRpbGVJbWFnZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGltZ0ZpbGVuYW1lKSB7XG5cdGlmICh0eXBlb2YgZWxlbWVudCAhPT0gJ29iamVjdCcpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnQgaXMgbm90IGFuIG9iamVjdCcpO1xuXHR9XG5cblx0ZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAndXJsKCcgKyBpbWdGaWxlbmFtZSArICcpJztcbn07XG5cbnZhciB0aWxlRmFjdG9yeSA9IG5ldyBUaWxlRmFjdG9yeSgpO1xuXG4vKipcbiAqIEBwYXJhbSBhcnJheSBvcHRpb25zXG4gKiBAcGFyYW0gb2JqZWN0IG9wdGlvbnMuY29udGFpbmVyIERPTSBlbGVtZW50IGZvciB0aGUgZ3JpZC5cbiAqIEBwYXJhbSBvYmplY3Qgb3B0aW9ucy50aWxlU2l6ZSBUaWxlIGhlaWdodC93aWR0aCBpbiBwaXhlbHMuXG4gKiBAcGFyYW0gb2JqZWN0IG9wdGlvbnMud2lkdGggR3JpZCB3aWR0aCBpbiB0aWxlcy5cbiAqIEBwYXJhbSBvYmplY3Qgb3B0aW9ucy5oZWlnaHQgR3JpZCBoZWlnaHQgaW4gdGlsZXMuXG4gKiBAcGFyYW0gb2JqZWN0IG9wdGlvbnMub25BbmltYXRpb25Db21wbGV0ZSBDYWxsYmFjayBmb3Igd2hlbiBhbmltYXRpb25cbiAqICAgICAgICBjb21wbGV0ZXMuXG4gKi9cbmZ1bmN0aW9uIEFwcChvcHRpb25zKSB7XG5cdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ211c3QgcHJvdmlkZSBhbiBvcHRpb25zIG9iamVjdCcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBvcHRpb25zLmNvbnRhaW5lciAhPT0gJ29iamVjdCcpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuY29udGFpbmVyIG11c3QgYmUgYW4gSFRNTCBlbGVtZW50Jyk7XG5cdH1cblxuXHR0aGlzLmNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyO1xuXG5cdGlmICh0eXBlb2Ygb3B0aW9ucy50aWxlU2l6ZSAhPT0gJ251bWJlcicpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMudGlsZVNpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBvcHRpb25zLndpZHRoICE9PSAnbnVtYmVyJykge1xuXHRcdHRocm93IG5ldyBFcnJvcignb3B0aW9ucy53aWR0aCBtdXN0IGJlIGEgbnVtYmVyJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG9wdGlvbnMuaGVpZ2h0ICE9PSAnbnVtYmVyJykge1xuXHRcdHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5oZWlnaHQgbXVzdCBiZSBhIG51bWJlcicpO1xuXHR9XG5cblx0dGhpcy53aWR0aCA9IG9wdGlvbnMud2lkdGg7XG5cdHRoaXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG5cdHRoaXMudGlsZVNpemUgPSBvcHRpb25zLnRpbGVTaXplO1xuXHR0aGlzLm9uQW5pbWF0aW9uQ29tcGxldGUgPSBvcHRpb25zLm9uQW5pbWF0aW9uQ29tcGxldGU7XG5cblx0dGhpcy5oZXhHcmlkID0gbmV3IEhleEdyaWQoe1xuXHRcdHdpZHRoOiBvcHRpb25zLndpZHRoLFxuXHRcdGhlaWdodDogb3B0aW9ucy5oZWlnaHQsXG5cdFx0b3JpZW50YXRpb246ICdmbGF0LXRvcHBlZCcsXG5cdFx0bGF5b3V0OiAnb2RkLXEnLFxuXHRcdHRpbGVGYWN0b3J5OiB0aWxlRmFjdG9yeVxuXHR9KTtcblxuXHR0aGlzLmR0ZCA9IG5ldyBEb21UaWxlRHJhd2VyKHtcblx0XHRwYXJlbnQ6IG9wdGlvbnMuY29udGFpbmVyLFxuXHRcdHRpbGVTaXplOiB0aGlzLnRpbGVTaXplXG5cdH0pO1xuXG5cdHZhciBpdGVyID0gdGhpcy5oZXhHcmlkLmdldFRpbGVJdGVyYXRvcigpO1xuXHR2YXIgdGlsZSA9IGl0ZXIubmV4dCgpO1xuXHR2YXIgdGlsZVBvcztcblx0d2hpbGUgKHRpbGUgIT09IG51bGwpIHtcblx0XHR0aWxlUG9zID0gdGhpcy5oZXhHcmlkLmdldFBvc2l0aW9uQnlJZCh0aWxlLmlkKTtcblx0XHR0aWxlLmVsZW1lbnQgPSB0aGlzLmR0ZC5jcmVhdGVEb21UaWxlKHRpbGVQb3MueCwgdGlsZVBvcy55KTtcblx0XHR0aGlzLmR0ZC5zZXRUaWxlSW1hZ2UoXG5cdFx0XHR0aWxlLmVsZW1lbnQsXG5cdFx0XHR0aGlzLmdldFRpbGVJbWFnZUJ5UG9zKHRpbGVQb3MueCwgdGlsZVBvcy55KVxuXHRcdCk7XG5cdFx0dGlsZSA9IGl0ZXIubmV4dCgpO1xuXHR9XG5cblx0dGhpcy5hdHRhY2hNb3VzZUV2ZW50cygpO1xuXHR0aGlzLmFuaW1hdGVMZWZ0VG9SaWdodCgpO1xufVxuXG5BcHAucHJvdG90eXBlLmdldFRpbGVJbWFnZUJ5UG9zID0gZnVuY3Rpb24oeCwgeSkge1xuXHQvLyBSZXN1bHRzIGluIGEgZGFyayBib3JkZXIuXG5cdGlmICh4ID09PSAwIHx8IHggPT09IHRoaXMud2lkdGggLSAxIHx8XG5cdFx0eSA9PT0gMCB8fFxuXHRcdCh5ID09PSB0aGlzLmhlaWdodCAtIDEgJiYgeCAlIDIgPT09IDApIHx8XG5cdFx0KHkgPT09IHRoaXMuaGVpZ2h0IC0gMC41ICYmIHggJSAyID09PSAxKVxuXHQpIHtcblx0XHRyZXR1cm4gJy4vaW1nL2RhcmstY2lyY2xlLnBuZyc7XG5cdH1cblxuXHRyZXR1cm4gJy4vaW1nL2xpZ2h0LWNpcmNsZS5wbmcnO1xufTtcblxuQXBwLnByb3RvdHlwZS5hdHRhY2hNb3VzZUV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgaXRlciA9IHRoaXMuaGV4R3JpZC5nZXRUaWxlSXRlcmF0b3IoKTtcblx0dmFyIHRpbGUgPSBpdGVyLm5leHQoKTtcblx0d2hpbGUgKHRpbGUgIT09IG51bGwpIHtcblx0XHR0aWxlLmVsZW1lbnQub25tb3VzZW92ZXIgPSBmdW5jdGlvbih0aWxlKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAodGlsZS5zZWxlY3RlZCAhPT0gdHJ1ZSkge1xuXHRcdFx0XHRcdHRoaXMuZHRkLnNldFRpbGVJbWFnZSh0aWxlLmVsZW1lbnQsICcuL2ltZy9kYXJrLWNpcmNsZS5wbmcnKTtcblx0XHRcdFx0fVxuXHRcdFx0fS5iaW5kKHRoaXMpO1xuXHRcdH0uYmluZCh0aGlzKSh0aWxlKTtcblxuXHRcdHRpbGUuZWxlbWVudC5vbm1vdXNlb3V0ID0gZnVuY3Rpb24odGlsZSkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKHRpbGUuc2VsZWN0ZWQgIT09IHRydWUpIHtcblx0XHRcdFx0XHR0aGlzLmR0ZC5zZXRUaWxlSW1hZ2UodGlsZS5lbGVtZW50LCAnLi9pbWcvbGlnaHQtY2lyY2xlLnBuZycpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LmJpbmQodGhpcyk7XG5cdFx0fS5iaW5kKHRoaXMpKHRpbGUpO1xuXG5cdFx0dGlsZS5lbGVtZW50Lm9ubW91c2Vkb3duID0gZnVuY3Rpb24odGlsZSkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGlsZS5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdHRoaXMuZHRkLnNldFRpbGVJbWFnZSh0aWxlLmVsZW1lbnQsICcuL2ltZy9yZWQtY2lyY2xlLnBuZycpO1xuXHRcdFx0fS5iaW5kKHRoaXMpO1xuXHRcdH0uYmluZCh0aGlzKSh0aWxlKTtcblxuXHRcdHRpbGUgPSBpdGVyLm5leHQoKTtcblx0fVxufTtcblxuQXBwLnByb3RvdHlwZS5hbmltYXRlTGVmdFRvUmlnaHQgPSBmdW5jdGlvbigpIHtcblx0dmFyIGl0ZXIgPSB0aGlzLmhleEdyaWQuZ2V0VGlsZUl0ZXJhdG9yKCk7XG5cdHZhciB0aWxlID0gaXRlci5uZXh0KCk7XG5cdHZhciBhbmltYXRpb25JbnRlcnZhbDtcblxuXHR2YXIgYW5pbWF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aWxlID09PSBudWxsKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJJbnRlcnZhbChhbmltYXRpb25JbnRlcnZhbCk7XG5cdFx0XHR0aGlzLmFuaW1hdGlvbkNvbXBsZXRlKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5kdGQuc2V0VGlsZUltYWdlKHRpbGUuZWxlbWVudCwgJy4vaW1nL2RhcmstY2lyY2xlLnBuZycpO1xuXHRcdHRpbGUgPSBpdGVyLm5leHQoKTtcblx0fS5iaW5kKHRoaXMpO1xuXG5cdGFuaW1hdGlvbkludGVydmFsID0gd2luZG93LnNldEludGVydmFsKGFuaW1hdGUsIDUwKTtcbn07XG5cbkFwcC5wcm90b3R5cGUuYW5pbWF0aW9uQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiB0aGlzLm9uQW5pbWF0aW9uQ29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHR0aGlzLm9uQW5pbWF0aW9uQ29tcGxldGUuY2FsbChudWxsLCB0aGlzKTtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBcHA7XG4iXX0=
